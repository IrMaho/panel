# ğŸ—ï¸ Flutter Enterprise Architecture Overview

## ğŸ“‹ Core Architecture Pattern

This project follows **MVVM (Model-View-ViewModel)** architecture with a **Feature-First** folder structure.

---

## ğŸ¯ MVVM Layer Responsibilities

### ğŸ“± View Layer
**Location**: `features/{feature}/view/`

**Responsibility**: UI presentation only

**Components**:
- **Pages**: Route entry points with DI setup
- **Views**: Composite layout sections
- **Widgets**: Reusable UI components

**Rules**:
- âœ… Display data from state
- âœ… Trigger actions via callbacks
- âœ… Handle user input
- âŒ NO business logic
- âŒ NO data manipulation
- âŒ NO direct repository access

---

### ğŸ›ï¸ ViewModel Layer
**Location**: `features/{feature}/bloc/`

**Responsibility**: State management and UI logic

**Components**:
- **Cubit**: State management (default choice)
- **Bloc**: State management with events (only when needed)
- **State**: Immutable state classes

**Rules**:
- âœ… Manage UI state
- âœ… Coordinate repository calls
- âœ… Handle user actions
- âœ… Emit new states
- âœ… Delegate complex logic to UseCases
- âŒ NO UI code
- âŒ NO direct API calls
- âŒ NO direct network/database access

---

### ğŸ“Š Model Layer
**Location**: `features/{feature}/model/`

**Responsibility**: Business logic and data access

**Components**:
- **Repositories**: Data access abstractions
- **DTOs/Entities**: Data models with JSON serialization
- **UseCases**: Complex business logic (when needed)

**Rules**:
- âœ… Define data access contracts (repositories)
- âœ… Implement data access logic
- âœ… Transform and validate data
- âœ… Handle complex business operations
- âŒ NO UI logic
- âŒ NO state management

---

## ğŸ“ Feature-First Structure

### Why Feature-First?

**âœ… Benefits**:
- Clear feature boundaries
- Easy to find related code
- Scalable for large teams
- Simple to add/remove features
- Better code ownership

**âŒ NOT Layer-First** (we don't do this):
```
lib/
â”œâ”€â”€ views/           # âŒ All views mixed together
â”œâ”€â”€ viewmodels/      # âŒ All cubits mixed together
â””â”€â”€ models/          # âŒ All models mixed together
```

### Core Project Structure

```
lib/
â”œâ”€â”€ core/                           # Shared infrastructure
â”‚   â”œâ”€â”€ model/                      # Core models & utilities
â”‚   â”‚   â”œâ”€â”€ network/                # HTTP client, error handling
â”‚   â”‚   â”œâ”€â”€ storage/                # Local storage abstractions
â”‚   â”‚   â”œâ”€â”€ validation/             # Form validation framework
â”‚   â”‚   â””â”€â”€ result.dart             # Result<T> pattern
â”‚   â”‚
â”‚   â”œâ”€â”€ view/                       # Shared UI
â”‚   â”‚   â””â”€â”€ widgets/                # Global reusable widgets
â”‚   â”‚
â”‚   â”œâ”€â”€ di/                         # Dependency injection
â”‚   â”‚   â””â”€â”€ service_locator.dart    # GetIt setup
â”‚   â”‚
â”‚   â”œâ”€â”€ router.dart                 # App navigation (go_router)
â”‚   â””â”€â”€ theme.dart                  # App theming
â”‚
â”œâ”€â”€ features/                       # All business features
â”‚   â””â”€â”€ {feature_name}/             # Single feature
â”‚       â”œâ”€â”€ {feature_name}_di.dart  # Feature DI registration
â”‚       â”‚
â”‚       â”œâ”€â”€ bloc/                   # ViewModel layer
â”‚       â”‚   â”œâ”€â”€ {feature}_cubit.dart
â”‚       â”‚   â””â”€â”€ {feature}_state.dart
â”‚       â”‚
â”‚       â”œâ”€â”€ model/                  # Model layer
â”‚       â”‚   â”œâ”€â”€ data/               # DTOs and entities
â”‚       â”‚   â”‚   â”œâ”€â”€ {entity}.dart
â”‚       â”‚   â”‚   â””â”€â”€ {entity}.g.dart
â”‚       â”‚   â”‚
â”‚       â”‚   â”œâ”€â”€ repositories/       # Data access
â”‚       â”‚   â”‚   â”œâ”€â”€ {entity}_repository.dart
â”‚       â”‚   â”‚   â””â”€â”€ {entity}_repository_impl.dart
â”‚       â”‚   â”‚
â”‚       â”‚   â””â”€â”€ usecases/           # Complex business logic (optional)
â”‚       â”‚       â””â”€â”€ {usecase}.dart
â”‚       â”‚
â”‚       â””â”€â”€ view/                   # View layer
â”‚           â”œâ”€â”€ {feature}_page.dart # Page (route)
â”‚           â”‚
â”‚           â”œâ”€â”€ views/              # Composite sections
â”‚           â”‚   â”œâ”€â”€ {section}_view.dart
â”‚           â”‚   â””â”€â”€ views.dart      # Barrel export
â”‚           â”‚
â”‚           â””â”€â”€ widgets/            # Feature widgets
â”‚               â”œâ”€â”€ {widget}.dart
â”‚               â””â”€â”€ widgets.dart    # Barrel export
â”‚
â””â”€â”€ main.dart                       # App entry point
```

---

## ğŸ”„ Data Flow

### Standard Flow (Read)
```
User Action (View)
    â†“
Cubit Method Call
    â†“
Repository Method
    â†“
Data Source (API/Database)
    â†“
Repository Returns Result<T>
    â†“
Cubit Emits New State
    â†“
View Rebuilds with New Data
```

### With UseCase (Complex Logic)
```
User Action (View)
    â†“
Cubit Method Call
    â†“
UseCase Execution
    â†“
Multiple Repository Calls
    â†“
Data Transformation/Validation
    â†“
UseCase Returns Result<T>
    â†“
Cubit Emits New State
    â†“
View Rebuilds
```

---

## ğŸ¯ When to Create UseCases

### âœ… CREATE UseCases When:
- Logic spans multiple repositories
- Complex data transformations needed
- Multi-step operations with validation
- Reusable logic across multiple Cubits
- Business rules require transaction-like behavior

**Example**: `ProcessPaymentUseCase` that:
1. Validates payment details
2. Calls payment gateway
3. Updates order status
4. Sends confirmation email
5. Updates user credits

### âŒ SKIP UseCases When:
- Simple CRUD operations (getAll, getById, create, update, delete)
- Direct repository pass-through with no logic
- Feature-specific logic only used once

**Example**: Just call `repository.getUsers()` directly from Cubit

---

## ğŸ”Œ Dependency Injection Philosophy

### Core Principle
**Inversion of Control**: Classes receive their dependencies rather than creating them.

### Pattern
```dart
// âœ… Dependencies injected via constructor
class FeatureCubit extends Cubit<FeatureState> {
  final FeatureRepository _repository;
  final AnalyticsService _analytics;
  
  FeatureCubit(this._repository, this._analytics) 
      : super(const FeatureState.initial());
}

// âŒ DON'T create dependencies internally
class BadCubit extends Cubit<State> {
  final repository = FeatureRepositoryImpl(); // âŒ Hard-coded dependency
}
```

### Registration Types
- **Singleton** (`registerLazySingleton`): One instance for app lifetime
  - Use for: Services, repositories, network clients
  
- **Factory** (`registerFactory`): New instance each time
  - Use for: Cubits, ViewModels, UseCases

---

## ğŸš« Architecture Violations

### âŒ FORBIDDEN Patterns

1. **Business Logic in Views**
```dart
// âŒ WRONG
class UserPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final users = getUsers(); // âŒ Data access in UI
    final filtered = users.where((u) => u.isActive); // âŒ Logic in UI
    return ListView(...);
  }
}
```

2. **Direct API Calls from Cubits**
```dart
// âŒ WRONG
class UsersCubit extends Cubit<UsersState> {
  Future<void> loadUsers() async {
    final response = await http.get('/users'); // âŒ Direct API call
  }
}
```

3. **Repository Inside Repository**
```dart
// âŒ WRONG
class UserRepositoryImpl implements UserRepository {
  final PostRepository _postRepo; // âŒ Repo depends on repo
}
```

4. **Cubit Inside Cubit**
```dart
// âŒ WRONG
class UsersCubit extends Cubit<UsersState> {
  final PostsCubit _postsCubit; // âŒ Cubit depends on cubit
}

// âœ… CORRECT: Listen to another Cubit's state
class UsersCubit extends Cubit<UsersState> {
  StreamSubscription? _postsSubscription;
  
  void initialize(PostsCubit postsCubit) {
    _postsSubscription = postsCubit.stream.listen((postsState) {
      // React to posts state changes
      if (postsState.hasNewPost) {
        loadUsers();
      }
    });
  }
}
```

5. **Returning Async Results from Cubit Methods**
```dart
// âŒ WRONG: Returning results instead of emitting state
class UsersCubit extends Cubit<UsersState> {
  Future<User?> getUser(String id) async { // âŒ Returns data
    return await _repository.getUser(id);
  }
}

// âœ… CORRECT: Emit state changes
class UsersCubit extends Cubit<UsersState> {
  Future<void> loadUser(String id) async { // âœ… Returns void
    emit(state.copyWith(isLoading: true));
    final result = await _repository.getUser(id);
    switch (result) {
      case Success(:final data):
        emit(state.copyWith(user: data, isLoading: false));
      case Failure(:final message):
        emit(state.copyWith(error: message, isLoading: false));
    }
  }
}
```

6. **God Classes/Files**
```dart
// âŒ WRONG: 2000+ line file with everything
class MegaService {
  void doEverything() { ... }
}
```

---

## âœ… Required Patterns

### 1. Repository Pattern
```dart
// Abstract contract
abstract class UserRepository {
  Future<Result<List<User>>> getUsers();
  Future<Result<User>> getUser(String id);
}

// Implementation
class UserRepositoryImpl implements UserRepository {
  final NetworkService _network;
  
  UserRepositoryImpl(this._network);
  
  @override
  Future<Result<List<User>>> getUsers() async {
    // Implementation
  }
}
```

### 2. UseCase Pattern (When Needed)
```dart
class ProcessCheckoutUseCase {
  final OrderRepository _orderRepo;
  final PaymentRepository _paymentRepo;
  final NotificationRepository _notificationRepo;
  
  ProcessCheckoutUseCase(
    this._orderRepo,
    this._paymentRepo,
    this._notificationRepo,
  );
  
  Future<Result<Order>> execute(CheckoutRequest request) async {
    // Multi-step business logic
  }
}
```

### 3. State Management with Cubit
```dart
class UsersCubit extends Cubit<UsersState> {
  final UserRepository _repository;
  
  UsersCubit(this._repository) : super(const UsersState.initial());
  
  Future<void> loadUsers() async {
    emit(state.copyWith(isLoading: true));
    // Repository call and state emission
  }
}
```

### 4. Error Handling with Mixin
```dart
mixin ErrorHandlingMixin<T> on Cubit<T> {
  void handleError(String message) {
    toastification.show(
      context: navigatorKey.currentContext!,
      type: ToastificationType.error,
      title: Text(message),
    );
  }
}
```

---

## ğŸ“š Architecture Principles Summary

### Single Responsibility
- Each class has ONE reason to change
- Each file contains ONE main concept

### Dependency Inversion
- Depend on abstractions (interfaces), not implementations
- High-level modules don't depend on low-level modules

### Separation of Concerns
- View handles presentation
- ViewModel handles state and coordination
- Model handles data and business logic

### Testability
- All dependencies are injectable
- All layers can be tested independently
- Mock implementations for testing

---

## ğŸ“ Key Takeaways

1. **Feature-First** folder structure for scalability
2. **MVVM** for clear separation of concerns
3. **Repository Pattern** for data access abstraction
4. **Cubit** for state management (Bloc only when needed)
5. **Dependency Injection** for loose coupling
6. **UseCases** only for complex multi-step operations
7. **Result<T>** for consistent error handling
8. **Atomic Design** for UI component hierarchy

---

This architecture ensures:
- âœ… Maintainability
- âœ… Testability
- âœ… Scalability
- âœ… Team collaboration
- âœ… Code reusability

Follow these principles strictly for all features.